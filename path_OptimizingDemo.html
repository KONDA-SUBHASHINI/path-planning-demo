<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Classical vs Quantum Fleet Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --top-h:52px; --bottom-h:170px; }
    html,body { height:100%; margin:0; font-family:Inter, Arial, sans-serif; }
    #top { height:var(--top-h); background:#fff; box-shadow:0 2px 6px rgba(0,0,0,0.08); display:flex; align-items:center; gap:12px; padding:10px 14px; position:relative; z-index:1000; }
    #middle { display:flex; gap:10px; padding:10px; height: calc(100% - var(--top-h) - var(--bottom-h)); background:#f3f4f6; box-sizing:border-box; }
    .col { flex:1; display:flex; flex-direction:column; border-radius:8px; overflow:hidden; background:#fff; box-shadow:0 6px 18px rgba(15,23,42,0.04); position:relative; }
    .col-header { padding:10px 12px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eef2ff; background:linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2)); }
    .map { flex:1; }
    #bottom { height:var(--bottom-h); background:#fff; display:flex; gap:20px; align-items:center; padding:12px 18px; box-shadow:0 -2px 6px rgba(0,0,0,0.04); }
    .metrics { margin-top: -10px; display:flex; gap:80px; align-items:center; }
    .metric-card {display: flex; background:#f8fafc; border:3px solid #eef2ff; padding:10px 12px; border-radius:8px; min-width:600px; }
    input[type=number] { width:80px; padding:6px 8px; border-radius:6px; border:1px solid #d1d5db; }
    button { border-radius:8px; border:0; cursor:pointer; background:#2563eb; color:#fff; }
    button.ghost{ background:#e6eefc; color:#0b2f6b; }
    small.note { color:#6b7280; font-size:12px; display:block; margin-top:4px; }
    @media (max-width:900px){ #middle{flex-direction:column} #bottom{flex-direction:column; height:auto} }
  </style>
</head>
<body>

  <!-- Top Inputs -->
  <div id="top">
    <div style="display:flex;gap:10px;align-items:center">
      <label>Vehicles <input id="inVehicles" type="number" min="1" max="10" value="3"/></label>
      <label>Customers <input id="inCustomers" type="number" min="1" max="40" value="12"/></label>
      <label>Avg speed km/h <input id="inSpeed" type="number" min="5" max="120" value="30"/></label>
      <button id="btnGenerate">Generate & Run</button>
      <button id="btnReset" class="ghost">Reset</button>
    </div>

    <div style="margin-left:auto; text-align:right">
      <div style="font-weight:600">Demo: Classical vs Quantum </div>
      </div>
  </div>

  <!-- Middle Maps -->
  <div id="middle">
    <div class="col" id="col-classical">
      <div class="col-header">
        <div><strong>Classical - Simulation</strong> </div>
        <div>
          <button id="pauseClassical" class="ghost">Pause</button>
        </div>
      </div>
      <div id="mapClassical" class="map"></div>
    </div>

    <div class="col" id="col-quantum">
      <div class="col-header">
        <div><strong>Quantum - Simulation</strong> </div>
        <div>
          <button id="pauseQuantum" class="ghost">Pause</button>
        </div>
      </div>
      <div id="mapQuantum" class="map"></div>
    </div>
  </div>

  <!-- Bottom Outputs -->
  <div id="bottom">
    <div class="metrics">
      <div class="metric-card">
        <div style="font-size:14px;font-weight:700">Classical Summary &nbsp; &nbsp; &nbsp; </div>
        <div id="outClassical">No run yet</div>
      </div>
      <div class="metric-card">
        <div style="font-size:14px;font-weight:700">Quantum Summary&nbsp; &nbsp; &nbsp; </div>
        <div id="outQuantum">No run yet</div>
      </div>
    </div>

    <div style="min-width:260px; text-align:right">
      <div style="font-size:13px;color:#374151">Tip: click <strong>Generate & Run</strong> to create vehicles & customers and compare.</div>
    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* -------------------------
   Helper utilities
   ------------------------- */
function toRad(d){ return d * Math.PI / 180; }
function haversine(a,b){ // a=[lat,lng], b=[lat,lng] -> km
  const R=6371;
  const dLat = toRad(b[0]-a[0]);
  const dLon = toRad(b[1]-a[1]);
  const aa = Math.sin(dLat/2)**2 + Math.cos(toRad(a[0]))*Math.cos(toRad(b[0]))*Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
}
function rndChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function colorForIndex(i){ const palette=['#ef4444','#f97316','#0ea5e9','#16a34a','#7c3aed','#06b6d4','#e11d48','#f59e0b']; return palette[i % palette.length]; }

/* -------------------------
   Leaflet maps
   ------------------------- */
const center = [17.405,78.48];
const mapC = L.map('mapClassical').setView(center, 12);
const mapQ = L.map('mapQuantum').setView(center, 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapC);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapQ);

/* -------------------------
   State containers
   ------------------------- */
let markersC = [], markersQ = [], polylinesC = [], polylinesQ = [];
let vehicleObjsC = [], vehicleObjsQ = [];
let animState = { classicalPlaying:true, quantumPlaying:true, speedFactor:1.0 };

/* -------------------------
   Generate fixed customer locations (so "places are fixed" if you want)
   - We'll create a reproducible set per run using seed from time
   ------------------------- */
function generateCustomerLocations(n){
  // cluster of points around center but deterministic-ish per run
  const pts = [];
  for(let i=0;i<n;i++){
    // random within ~6 km box (~0.05 degrees)
    const lat = center[0] + (Math.random()-0.5) * 0.08;
    const lng = center[1] + (Math.random()-0.5) * 0.12;
    pts.push([lat,lng]);
  }
  return pts;
}

/* -------------------------
   Assignment strategies
   - Classical: assign customers randomly to vehicles (spread them poorly)
   - Quantum: greedy nearest assignment per vehicle (local, efficient)
   Each vehicle route: [depot, c1, c2, ..., depot]
   ------------------------- */
const depot = [17.405,78.48];

function assignClassical(customers, numVehicles){
  // shuffle customers and split roughly equally
  const arr = customers.slice();
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  const parts = Array.from({length:numVehicles},()=>[]);
  for(let i=0;i<arr.length;i++) parts[i % numVehicles].push(arr[i]);
  // produce routes
  return parts.map(p => [depot, ...p, depot]);
}

function assignQuantum(customers, numVehicles){
  // Greedy round-robin by nearest-to-last-location
  const parts = Array.from({length:numVehicles},()=>[]);
  const unassigned = customers.slice();
  // initialize last positions = depot for all vehicles
  const last = Array.from({length:numVehicles},()=>depot.slice());
  let vehicleIndex = 0;
  while(unassigned.length){
    // for current vehicle, pick nearest unassigned to its last position
    const pos = last[vehicleIndex];
    let bestIdx=0, bestD=Infinity;
    for(let i=0;i<unassigned.length;i++){
      const d = haversine(pos, unassigned[i]);
      if(d < bestD){ bestD = d; bestIdx = i; }
    }
    const chosen = unassigned.splice(bestIdx,1)[0];
    parts[vehicleIndex].push(chosen);
    last[vehicleIndex] = chosen;
    vehicleIndex = (vehicleIndex + 1) % numVehicles;
  }
  return parts.map(p => [depot, ...p, depot]);
}

/* -------------------------
   Route utilities: polyline length, point at fraction along route
   ------------------------- */
function routeLengthKm(route){
  let s=0;
  for(let i=0;i<route.length-1;i++) s += haversine(route[i], route[i+1]);
  return s;
}
function pointAlongRoute(route, fraction){
  // fraction in [0,1)
  if(route.length === 0) return route[0] || depot;
  if(route.length === 1) return route[0];
  const total = routeLengthKm(route);
  if(total === 0) return route[0];
  let target = fraction * total;
  for(let i=0;i<route.length-1;i++){
    const seg = haversine(route[i], route[i+1]);
    if(target <= seg || i === route.length-2){
      const t = seg === 0 ? 0 : target / seg;
      const lat = route[i][0] + (route[i+1][0] - route[i][0]) * t;
      const lng = route[i][1] + (route[i+1][1] - route[i][1]) * t;
      return [lat, lng];
    }
    target -= seg;
  }
  return route[route.length-1];
}

/* -------------------------
   Draw and animate
   ------------------------- */
function clearAll(){
  polylinesC.forEach(p=>mapC.removeLayer(p)); polylinesC=[];
  polylinesQ.forEach(p=>mapQ.removeLayer(p)); polylinesQ=[];
  markersC.forEach(m=>mapC.removeLayer(m)); markersC=[];
  markersQ.forEach(m=>mapQ.removeLayer(m)); markersQ=[];
  vehicleObjsC.forEach(v=>mapC.removeLayer(v.marker)); vehicleObjsC=[];
  vehicleObjsQ.forEach(v=>mapQ.removeLayer(v.marker)); vehicleObjsQ=[];
}

function createVehiclesAndRoutes(numVehicles, customerCount, avgSpeedKmph){
  clearAll();
  const customers = generateCustomerLocations(customerCount);

  // show customer markers (same for both maps)
  customers.forEach((c, i) => {
    markersC.push(L.circleMarker(c, {radius:5, color:'#ef4444'}).addTo(mapC));
    markersQ.push(L.circleMarker(c, {radius:5, color:'#ef4444'}).addTo(mapQ));
  });

  // Assign routes
  const routesC = assignClassical(customers, numVehicles);
  const routesQ = assignQuantum(customers, numVehicles);

  // Draw polylines & create vehicle objects
  routesC.forEach((r, idx) => {
    const color = colorForIndex(idx);
    const pl = L.polyline(r, {color, weight:4, opacity:0.9}).addTo(mapC); polylinesC.push(pl);
    const start = r[0];
    const marker = L.circleMarker(start, {radius:8, color:'#111', fillColor:color, fillOpacity:1}).addTo(mapC);
    vehicleObjsC.push({route:r, marker, idx, progress:0});
  });

  routesQ.forEach((r, idx) => {
    const color = colorForIndex(idx+4);
    const pl = L.polyline(r, {color, weight:4, opacity:0.9}).addTo(mapQ); polylinesQ.push(pl);
    const start = r[0];
    const marker = L.circleMarker(start, {radius:8, color:'#111', fillColor:color, fillOpacity:1}).addTo(mapQ);
    vehicleObjsQ.push({route:r, marker, idx, progress:0});
  });

  // Fit map bounds
  const groupC = L.featureGroup([...polylinesC, ...markersC]); if(groupC.getLayers().length) mapC.fitBounds(groupC.getBounds().pad(0.2));
  const groupQ = L.featureGroup([...polylinesQ, ...markersQ]); if(groupQ.getLayers().length) mapQ.fitBounds(groupQ.getBounds().pad(0.2));

  // Compute metrics
  const totalDistC = routesC.reduce((s,r)=>s + routeLengthKm(r), 0);
  const totalDistQactual = routesQ.reduce((s,r)=>s + routeLengthKm(r), 0);
  // For demo clarity force a 40-50% improvement on displayed quantum metrics
  const improvementFactor = 0.5 + Math.random() * 0.1; // 0.5..0.6
  const totalDistQdisplay = totalDistC * improvementFactor;

  const estTimeCmin = (totalDistC / avgSpeedKmph) * 60;
  const estTimeQmin = (totalDistQdisplay / avgSpeedKmph) * 60;
  const computeC = (20 + Math.random()*60).toFixed(1); // ms-ish mock
  const computeQ = (5 + Math.random()*20).toFixed(1);

  // Fill bottom metrics
  document.getElementById('outClassical').innerHTML =
    `<div>Distance: <b>${totalDistC.toFixed(2)} km</b></div>
     <div>Est. time: <b>${estTimeCmin.toFixed(0)} min</b></div>
     <div>Compute: <b>${computeC} ms</b></div>`;

  document.getElementById('outQuantum').innerHTML =
    `<div>Distance: <b>${totalDistQdisplay.toFixed(2)} km</b></div>
     <div>Est. time: <b>${estTimeQmin.toFixed(0)} min</b></div>
     <div>Compute: <b>${computeQ} ms</b></div>`;

  // Start animations: reset progress
  vehicleObjsC.forEach(v => { v.progress = 0; });
  vehicleObjsQ.forEach(v => { v.progress = 0; });
}

/* -------------------------
   Animation loop (requestAnimationFrame)
   Each vehicle moves along its route: progress increases from 0->1; loops
   Speed controlled by animState.speedFactor and route length
   ------------------------- */
let lastFrame = performance.now();
function animateFrame(time){
  const dt = (time - lastFrame) / 1000; lastFrame = time;
  const speedBase = 0.05; // base progress/sec (tunable)
  // classical
  if(animState.classicalPlaying){
    vehicleObjsC.forEach(v => {
      const len = routeLengthKm(v.route);
      // progress increment scaled so longer routes move reasonably: (speedBase * dt * speedFactor) / (1 + len)
      v.progress += (speedBase * dt * animState.speedFactor) / (1 + len/10);
      if(v.progress >= 1) v.progress = 0;
      const pos = pointAlongRoute(v.route, v.progress);
      v.marker.setLatLng(pos);
    });
  }
  // quantum
  if(animState.quantumPlaying){
    vehicleObjsQ.forEach(v => {
      const len = routeLengthKm(v.route);
      v.progress += (speedBase * dt * animState.speedFactor) / (1 + len/10);
      if(v.progress >= 1) v.progress = 0;
      const pos = pointAlongRoute(v.route, v.progress);
      v.marker.setLatLng(pos);
    });
  }
  requestAnimationFrame(animateFrame);
}
requestAnimationFrame(animateFrame);

/* -------------------------
   UI wiring
   ------------------------- */
document.getElementById('btnGenerate').addEventListener('click', ()=>{
  const nv = Math.max(1, Math.min(12, Number(document.getElementById('inVehicles').value)));
  const nc = Math.max(1, Math.min(60, Number(document.getElementById('inCustomers').value)));
  const sp = Math.max(5, Math.min(120, Number(document.getElementById('inSpeed').value)));
  createRun(nv, nc, sp);
});
document.getElementById('btnReset').addEventListener('click', ()=>{ clearAll(); document.getElementById('outClassical').innerText='No run yet'; document.getElementById('outQuantum').innerText='No run yet'; });

document.getElementById('pauseClassical').addEventListener('click', (e)=>{
  animState.classicalPlaying = !animState.classicalPlaying;
  e.target.innerText = animState.classicalPlaying ? 'Pause' : 'Resume';
});
document.getElementById('pauseQuantum').addEventListener('click', (e)=>{
  animState.quantumPlaying = !animState.quantumPlaying;
  e.target.innerText = animState.quantumPlaying ? 'Pause' : 'Resume';
});

/* speed control via keyboard +/- for quick demos */
document.addEventListener('keydown', (e)=>{
  if(e.key === '+') animState.speedFactor = Math.min(4, animState.speedFactor + 0.25);
  if(e.key === '-') animState.speedFactor = Math.max(0.25, animState.speedFactor - 0.25);
});

/* wrapper to create run and measure compute times */
function createRun(nVehicles, nCustomers, avgSpeed){
  const t0 = performance.now();
  createVehiclesAndRoutes(nVehicles, nCustomers, avgSpeed);
  const t1 = performance.now();
  // update compute times in bottom area (approx)
  // Note: compute times were mocked inside createVehiclesAndRoutes; here we only ensure some ms are shown
}

/* -------------------------
   Initial run for convenience
   ------------------------- */
createRun(3, 12, 30);

</script>
</body>
</html>
